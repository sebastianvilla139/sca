// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "group.hxx"

// group
// 

const group::behaviour_sequence& group::
behaviour () const
{
  return this->behaviour_;
}

group::behaviour_sequence& group::
behaviour ()
{
  return this->behaviour_;
}

void group::
behaviour (const behaviour_sequence& s)
{
  this->behaviour_ = s;
}

const group::description_optional& group::
description () const
{
  return this->description_;
}

group::description_optional& group::
description ()
{
  return this->description_;
}

void group::
description (const description_type& x)
{
  this->description_.set (x);
}

void group::
description (const description_optional& x)
{
  this->description_ = x;
}

void group::
description (::std::auto_ptr< description_type > x)
{
  this->description_.set (x);
}


// behaviour
// 

const behaviour::person_sequence& behaviour::
person () const
{
  return this->person_;
}

behaviour::person_sequence& behaviour::
person ()
{
  return this->person_;
}

void behaviour::
person (const person_sequence& s)
{
  this->person_ = s;
}

const behaviour::type_optional& behaviour::
type () const
{
  return this->type_;
}

behaviour::type_optional& behaviour::
type ()
{
  return this->type_;
}

void behaviour::
type (const type_type& x)
{
  this->type_.set (x);
}

void behaviour::
type (const type_optional& x)
{
  this->type_ = x;
}

void behaviour::
type (::std::auto_ptr< type_type > x)
{
  this->type_.set (x);
}


// person
// 

const person::profile_sequence& person::
profile () const
{
  return this->profile_;
}

person::profile_sequence& person::
profile ()
{
  return this->profile_;
}

void person::
profile (const profile_sequence& s)
{
  this->profile_ = s;
}

const person::id_optional& person::
id () const
{
  return this->id_;
}

person::id_optional& person::
id ()
{
  return this->id_;
}

void person::
id (const id_type& x)
{
  this->id_.set (x);
}

void person::
id (const id_optional& x)
{
  this->id_ = x;
}

const person::description_optional& person::
description () const
{
  return this->description_;
}

person::description_optional& person::
description ()
{
  return this->description_;
}

void person::
description (const description_type& x)
{
  this->description_.set (x);
}

void person::
description (const description_optional& x)
{
  this->description_ = x;
}

void person::
description (::std::auto_ptr< description_type > x)
{
  this->description_.set (x);
}


// profile
// 

const profile::frame_sequence& profile::
frame () const
{
  return this->frame_;
}

profile::frame_sequence& profile::
frame ()
{
  return this->frame_;
}

void profile::
frame (const frame_sequence& s)
{
  this->frame_ = s;
}

const profile::type_optional& profile::
type () const
{
  return this->type_;
}

profile::type_optional& profile::
type ()
{
  return this->type_;
}

void profile::
type (const type_type& x)
{
  this->type_.set (x);
}

void profile::
type (const type_optional& x)
{
  this->type_ = x;
}

void profile::
type (::std::auto_ptr< type_type > x)
{
  this->type_.set (x);
}


// frame
// 

const frame::bb_type& frame::
bb () const
{
  return this->bb_.get ();
}

frame::bb_type& frame::
bb ()
{
  return this->bb_.get ();
}

void frame::
bb (const bb_type& x)
{
  this->bb_.set (x);
}

void frame::
bb (::std::auto_ptr< bb_type > x)
{
  this->bb_.set (x);
}

const frame::no_optional& frame::
no () const
{
  return this->no_;
}

frame::no_optional& frame::
no ()
{
  return this->no_;
}

void frame::
no (const no_type& x)
{
  this->no_.set (x);
}

void frame::
no (const no_optional& x)
{
  this->no_ = x;
}


// bb
// 

const bb::ul_x_optional& bb::
ul_x () const
{
  return this->ul_x_;
}

bb::ul_x_optional& bb::
ul_x ()
{
  return this->ul_x_;
}

void bb::
ul_x (const ul_x_type& x)
{
  this->ul_x_.set (x);
}

void bb::
ul_x (const ul_x_optional& x)
{
  this->ul_x_ = x;
}

const bb::ul_y_optional& bb::
ul_y () const
{
  return this->ul_y_;
}

bb::ul_y_optional& bb::
ul_y ()
{
  return this->ul_y_;
}

void bb::
ul_y (const ul_y_type& x)
{
  this->ul_y_.set (x);
}

void bb::
ul_y (const ul_y_optional& x)
{
  this->ul_y_ = x;
}

const bb::lr_x_optional& bb::
lr_x () const
{
  return this->lr_x_;
}

bb::lr_x_optional& bb::
lr_x ()
{
  return this->lr_x_;
}

void bb::
lr_x (const lr_x_type& x)
{
  this->lr_x_.set (x);
}

void bb::
lr_x (const lr_x_optional& x)
{
  this->lr_x_ = x;
}

const bb::lr_y_optional& bb::
lr_y () const
{
  return this->lr_y_;
}

bb::lr_y_optional& bb::
lr_y ()
{
  return this->lr_y_;
}

void bb::
lr_y (const lr_y_type& x)
{
  this->lr_y_.set (x);
}

void bb::
lr_y (const lr_y_optional& x)
{
  this->lr_y_ = x;
}

const bb::or_optional& bb::
or_ () const
{
  return this->or__;
}

bb::or_optional& bb::
or_ ()
{
  return this->or__;
}

void bb::
or_ (const or_type& x)
{
  this->or__.set (x);
}

void bb::
or_ (const or_optional& x)
{
  this->or__ = x;
}

const bb::gp_x_optional& bb::
gp_x () const
{
  return this->gp_x_;
}

bb::gp_x_optional& bb::
gp_x ()
{
  return this->gp_x_;
}

void bb::
gp_x (const gp_x_type& x)
{
  this->gp_x_.set (x);
}

void bb::
gp_x (const gp_x_optional& x)
{
  this->gp_x_ = x;
}

const bb::gp_y_optional& bb::
gp_y () const
{
  return this->gp_y_;
}

bb::gp_y_optional& bb::
gp_y ()
{
  return this->gp_y_;
}

void bb::
gp_y (const gp_y_type& x)
{
  this->gp_y_.set (x);
}

void bb::
gp_y (const gp_y_optional& x)
{
  this->gp_y_ = x;
}

const bb::gp_or_optional& bb::
gp_or () const
{
  return this->gp_or_;
}

bb::gp_or_optional& bb::
gp_or ()
{
  return this->gp_or_;
}

void bb::
gp_or (const gp_or_type& x)
{
  this->gp_or_.set (x);
}

void bb::
gp_or (const gp_or_optional& x)
{
  this->gp_or_ = x;
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// group
//

group::
group ()
: ::xml_schema::type (),
  behaviour_ (this),
  description_ (this)
{
}

group::
group (const group& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  behaviour_ (x.behaviour_, f, this),
  description_ (x.description_, f, this)
{
}

group::
group (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  behaviour_ (this),
  description_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void group::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // behaviour
    //
    if (n.name () == "behaviour" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< behaviour_type > r (
        behaviour_traits::create (i, f, this));

      this->behaviour_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "description" && n.namespace_ ().empty ())
    {
      this->description_.set (description_traits::create (i, f, this));
      continue;
    }
  }
}

group* group::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class group (*this, f, c);
}

group& group::
operator= (const group& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->behaviour_ = x.behaviour_;
    this->description_ = x.description_;
  }

  return *this;
}

group::
~group ()
{
}

// behaviour
//

behaviour::
behaviour ()
: ::xml_schema::type (),
  person_ (this),
  type_ (this)
{
}

behaviour::
behaviour (const behaviour& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  person_ (x.person_, f, this),
  type_ (x.type_, f, this)
{
}

behaviour::
behaviour (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  person_ (this),
  type_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void behaviour::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // person
    //
    if (n.name () == "person" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< person_type > r (
        person_traits::create (i, f, this));

      this->person_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (type_traits::create (i, f, this));
      continue;
    }
  }
}

behaviour* behaviour::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class behaviour (*this, f, c);
}

behaviour& behaviour::
operator= (const behaviour& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->person_ = x.person_;
    this->type_ = x.type_;
  }

  return *this;
}

behaviour::
~behaviour ()
{
}

// person
//

person::
person ()
: ::xml_schema::type (),
  profile_ (this),
  id_ (this),
  description_ (this)
{
}

person::
person (const person& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  profile_ (x.profile_, f, this),
  id_ (x.id_, f, this),
  description_ (x.description_, f, this)
{
}

person::
person (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  profile_ (this),
  id_ (this),
  description_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void person::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // profile
    //
    if (n.name () == "profile" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< profile_type > r (
        profile_traits::create (i, f, this));

      this->profile_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "description" && n.namespace_ ().empty ())
    {
      this->description_.set (description_traits::create (i, f, this));
      continue;
    }
  }
}

person* person::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class person (*this, f, c);
}

person& person::
operator= (const person& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->profile_ = x.profile_;
    this->id_ = x.id_;
    this->description_ = x.description_;
  }

  return *this;
}

person::
~person ()
{
}

// profile
//

profile::
profile ()
: ::xml_schema::type (),
  frame_ (this),
  type_ (this)
{
}

profile::
profile (const profile& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  frame_ (x.frame_, f, this),
  type_ (x.type_, f, this)
{
}

profile::
profile (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  frame_ (this),
  type_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void profile::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // frame
    //
    if (n.name () == "frame" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< frame_type > r (
        frame_traits::create (i, f, this));

      this->frame_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (type_traits::create (i, f, this));
      continue;
    }
  }
}

profile* profile::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class profile (*this, f, c);
}

profile& profile::
operator= (const profile& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->frame_ = x.frame_;
    this->type_ = x.type_;
  }

  return *this;
}

profile::
~profile ()
{
}

// frame
//

frame::
frame (const bb_type& bb)
: ::xml_schema::type (),
  bb_ (bb, this),
  no_ (this)
{
}

frame::
frame (::std::auto_ptr< bb_type > bb)
: ::xml_schema::type (),
  bb_ (bb, this),
  no_ (this)
{
}

frame::
frame (const frame& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  bb_ (x.bb_, f, this),
  no_ (x.no_, f, this)
{
}

frame::
frame (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  bb_ (this),
  no_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void frame::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // bb
    //
    if (n.name () == "bb" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< bb_type > r (
        bb_traits::create (i, f, this));

      if (!bb_.present ())
      {
        this->bb_.set (r);
        continue;
      }
    }

    break;
  }

  if (!bb_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "bb",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "no" && n.namespace_ ().empty ())
    {
      this->no_.set (no_traits::create (i, f, this));
      continue;
    }
  }
}

frame* frame::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class frame (*this, f, c);
}

frame& frame::
operator= (const frame& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->bb_ = x.bb_;
    this->no_ = x.no_;
  }

  return *this;
}

frame::
~frame ()
{
}

// bb
//

bb::
bb ()
: ::xml_schema::string (),
  ul_x_ (this),
  ul_y_ (this),
  lr_x_ (this),
  lr_y_ (this),
  or__ (this),
  gp_x_ (this),
  gp_y_ (this),
  gp_or_ (this)
{
}

bb::
bb (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  ul_x_ (this),
  ul_y_ (this),
  lr_x_ (this),
  lr_y_ (this),
  or__ (this),
  gp_x_ (this),
  gp_y_ (this),
  gp_or_ (this)
{
}

bb::
bb (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  ul_x_ (this),
  ul_y_ (this),
  lr_x_ (this),
  lr_y_ (this),
  or__ (this),
  gp_x_ (this),
  gp_y_ (this),
  gp_or_ (this)
{
}

bb::
bb (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  ul_x_ (this),
  ul_y_ (this),
  lr_x_ (this),
  lr_y_ (this),
  or__ (this),
  gp_x_ (this),
  gp_y_ (this),
  gp_or_ (this)
{
}

bb::
bb (const bb& x,
    ::xml_schema::flags f,
    ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  ul_x_ (x.ul_x_, f, this),
  ul_y_ (x.ul_y_, f, this),
  lr_x_ (x.lr_x_, f, this),
  lr_y_ (x.lr_y_, f, this),
  or__ (x.or__, f, this),
  gp_x_ (x.gp_x_, f, this),
  gp_y_ (x.gp_y_, f, this),
  gp_or_ (x.gp_or_, f, this)
{
}

bb::
bb (const ::xercesc::DOMElement& e,
    ::xml_schema::flags f,
    ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  ul_x_ (this),
  ul_y_ (this),
  lr_x_ (this),
  lr_y_ (this),
  or__ (this),
  gp_x_ (this),
  gp_y_ (this),
  gp_or_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void bb::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "ul_x" && n.namespace_ ().empty ())
    {
      this->ul_x_.set (ul_x_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "ul_y" && n.namespace_ ().empty ())
    {
      this->ul_y_.set (ul_y_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "lr_x" && n.namespace_ ().empty ())
    {
      this->lr_x_.set (lr_x_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "lr_y" && n.namespace_ ().empty ())
    {
      this->lr_y_.set (lr_y_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "or" && n.namespace_ ().empty ())
    {
      this->or__.set (or_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "gp_x" && n.namespace_ ().empty ())
    {
      this->gp_x_.set (gp_x_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "gp_y" && n.namespace_ ().empty ())
    {
      this->gp_y_.set (gp_y_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "gp_or" && n.namespace_ ().empty ())
    {
      this->gp_or_.set (gp_or_traits::create (i, f, this));
      continue;
    }
  }
}

bb* bb::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class bb (*this, f, c);
}

bb& bb::
operator= (const bb& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::string& > (*this) = x;
    this->ul_x_ = x.ul_x_;
    this->ul_y_ = x.ul_y_;
    this->lr_x_ = x.lr_x_;
    this->lr_y_ = x.lr_y_;
    this->or__ = x.or__;
    this->gp_x_ = x.gp_x_;
    this->gp_y_ = x.gp_y_;
    this->gp_or_ = x.gp_or_;
  }

  return *this;
}

bb::
~bb ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::auto_ptr< ::group >
group_ (const ::std::string& u,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::group > (
    ::group_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::group >
group_ (const ::std::string& u,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::group > (
    ::group_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::group >
group_ (const ::std::string& u,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::group > (
    ::group_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::group >
group_ (::std::istream& is,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::group_ (isrc, f, p);
}

::std::auto_ptr< ::group >
group_ (::std::istream& is,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::group_ (isrc, h, f, p);
}

::std::auto_ptr< ::group >
group_ (::std::istream& is,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::group_ (isrc, h, f, p);
}

::std::auto_ptr< ::group >
group_ (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::group_ (isrc, f, p);
}

::std::auto_ptr< ::group >
group_ (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::group_ (isrc, h, f, p);
}

::std::auto_ptr< ::group >
group_ (::std::istream& is,
        const ::std::string& sid,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::group_ (isrc, h, f, p);
}

::std::auto_ptr< ::group >
group_ (::xercesc::InputSource& i,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::group > (
    ::group_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::group >
group_ (::xercesc::InputSource& i,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::group > (
    ::group_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::group >
group_ (::xercesc::InputSource& i,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::group > (
    ::group_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::group >
group_ (const ::xercesc::DOMDocument& doc,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::group > (
      ::group_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "group" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::group > r (
      ::xsd::cxx::tree::traits< ::group, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "group",
    "");
}

::std::auto_ptr< ::group >
group_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
        ::xml_schema::flags f,
        const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "group" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::group > r (
      ::xsd::cxx::tree::traits< ::group, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "group",
    "");
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

